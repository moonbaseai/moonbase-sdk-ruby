module Moonbase
  module Models
    type call_upsert_params =
      {
        direction: Moonbase::Models::CallUpsertParams::direction,
        participants: ::Array[Moonbase::CallUpsertParams::Participant],
        provider: String,
        provider_id: String,
        start_at: Time,
        status: Moonbase::Models::CallUpsertParams::status,
        answered_at: Time,
        end_at: Time,
        provider_metadata: ::Hash[Symbol, top],
        recordings: ::Array[Moonbase::CallUpsertParams::Recording],
        transcript: Moonbase::CallUpsertParams::Transcript
      }
      & Moonbase::Internal::Type::request_parameters

    class CallUpsertParams < Moonbase::Internal::Type::BaseModel
      extend Moonbase::Internal::Type::RequestParameters::Converter
      include Moonbase::Internal::Type::RequestParameters

      attr_accessor direction: Moonbase::Models::CallUpsertParams::direction

      attr_accessor participants: ::Array[Moonbase::CallUpsertParams::Participant]

      attr_accessor provider: String

      attr_accessor provider_id: String

      attr_accessor start_at: Time

      attr_accessor status: Moonbase::Models::CallUpsertParams::status

      attr_reader answered_at: Time?

      def answered_at=: (Time) -> Time

      attr_reader end_at: Time?

      def end_at=: (Time) -> Time

      attr_reader provider_metadata: ::Hash[Symbol, top]?

      def provider_metadata=: (::Hash[Symbol, top]) -> ::Hash[Symbol, top]

      attr_reader recordings: ::Array[Moonbase::CallUpsertParams::Recording]?

      def recordings=: (
        ::Array[Moonbase::CallUpsertParams::Recording]
      ) -> ::Array[Moonbase::CallUpsertParams::Recording]

      attr_reader transcript: Moonbase::CallUpsertParams::Transcript?

      def transcript=: (
        Moonbase::CallUpsertParams::Transcript
      ) -> Moonbase::CallUpsertParams::Transcript

      def initialize: (
        direction: Moonbase::Models::CallUpsertParams::direction,
        participants: ::Array[Moonbase::CallUpsertParams::Participant],
        provider: String,
        provider_id: String,
        start_at: Time,
        status: Moonbase::Models::CallUpsertParams::status,
        ?answered_at: Time,
        ?end_at: Time,
        ?provider_metadata: ::Hash[Symbol, top],
        ?recordings: ::Array[Moonbase::CallUpsertParams::Recording],
        ?transcript: Moonbase::CallUpsertParams::Transcript,
        ?request_options: Moonbase::request_opts
      ) -> void

      def to_hash: -> {
        direction: Moonbase::Models::CallUpsertParams::direction,
        participants: ::Array[Moonbase::CallUpsertParams::Participant],
        provider: String,
        provider_id: String,
        start_at: Time,
        status: Moonbase::Models::CallUpsertParams::status,
        answered_at: Time,
        end_at: Time,
        provider_metadata: ::Hash[Symbol, top],
        recordings: ::Array[Moonbase::CallUpsertParams::Recording],
        transcript: Moonbase::CallUpsertParams::Transcript,
        request_options: Moonbase::RequestOptions
      }

      type direction = :incoming | :outgoing

      module Direction
        extend Moonbase::Internal::Type::Enum

        INCOMING: :incoming
        OUTGOING: :outgoing

        def self?.values: -> ::Array[Moonbase::Models::CallUpsertParams::direction]
      end

      type participant =
        {
          phone: String,
          role: Moonbase::Models::CallUpsertParams::Participant::role
        }

      class Participant < Moonbase::Internal::Type::BaseModel
        attr_accessor phone: String

        attr_accessor role: Moonbase::Models::CallUpsertParams::Participant::role

        def initialize: (
          phone: String,
          role: Moonbase::Models::CallUpsertParams::Participant::role
        ) -> void

        def to_hash: -> {
          phone: String,
          role: Moonbase::Models::CallUpsertParams::Participant::role
        }

        type role = :caller | :callee | :other

        module Role
          extend Moonbase::Internal::Type::Enum

          CALLER: :caller
          CALLEE: :callee
          OTHER: :other

          def self?.values: -> ::Array[Moonbase::Models::CallUpsertParams::Participant::role]
        end
      end

      type status =
        :queued
        | :initiated
        | :ringing
        | :in_progress
        | :completed
        | :busy
        | :failed
        | :no_answer
        | :canceled
        | :missed
        | :answered
        | :forwarded
        | :abandoned

      module Status
        extend Moonbase::Internal::Type::Enum

        QUEUED: :queued
        INITIATED: :initiated
        RINGING: :ringing
        IN_PROGRESS: :in_progress
        COMPLETED: :completed
        BUSY: :busy
        FAILED: :failed
        NO_ANSWER: :no_answer
        CANCELED: :canceled
        MISSED: :missed
        ANSWERED: :answered
        FORWARDED: :forwarded
        ABANDONED: :abandoned

        def self?.values: -> ::Array[Moonbase::Models::CallUpsertParams::status]
      end

      type recording =
        { content_type: String, provider_id: String, url: String }

      class Recording < Moonbase::Internal::Type::BaseModel
        attr_accessor content_type: String

        attr_accessor provider_id: String

        attr_accessor url: String

        def initialize: (
          content_type: String,
          provider_id: String,
          url: String
        ) -> void

        def to_hash: -> {
          content_type: String,
          provider_id: String,
          url: String
        }
      end

      type transcript =
        { cues: ::Array[Moonbase::CallUpsertParams::Transcript::Cue] }

      class Transcript < Moonbase::Internal::Type::BaseModel
        attr_accessor cues: ::Array[Moonbase::CallUpsertParams::Transcript::Cue]

        def initialize: (
          cues: ::Array[Moonbase::CallUpsertParams::Transcript::Cue]
        ) -> void

        def to_hash: -> {
          cues: ::Array[Moonbase::CallUpsertParams::Transcript::Cue]
        }

        type cue = { from: Float, speaker: String, text: String, to: Float }

        class Cue < Moonbase::Internal::Type::BaseModel
          attr_accessor from: Float

          attr_accessor speaker: String

          attr_accessor text: String

          attr_accessor to: Float

          def initialize: (
            from: Float,
            speaker: String,
            text: String,
            to: Float
          ) -> void

          def to_hash: -> {
            from: Float,
            speaker: String,
            text: String,
            to: Float
          }
        end
      end
    end
  end
end
